{"version":3,"file":"jwt.js","sourceRoot":"","sources":["../../../src/config/jwt.ts"],"names":[],"mappings":"AACA,4EAA4E;AAC5E,OAAO,GAA4B,MAAM,cAAc,CAAC;AACxD,OAAO,MAAM,MAAM,QAAQ,CAAC;AAG5B,MAAM,CAAC,MAAM,EAAE,CAAC;AAEhB,0DAA0D;AAE1D,aAAa;AACb,kCAAkC;AAClC,6DAA6D;AAC7D,+EAA+E;AAC/E,gGAAgG;AAEhG,MAAM,UAAU,GAAW,OAAO,CAAC,GAAG,CAAC,UAAU,IAAI,YAAY,CAAC;AAClE,MAAM,gBAAgB,GACpB,OAAO,CAAC,GAAG,CAAC,gBAAgB,IAAI,kBAAkB,CAAC;AACrD,MAAM,cAAc,GAAW,OAAO,CAAC,GAAG,CAAC,qBAAqB,IAAI,IAAI,CAAC;AAOzE,uBAAuB;AAEvB,iCAAiC;AACjC,oEAAoE;AACpE,kFAAkF;AAClF,kCAAkC;AAClC,OAAO;AACP,KAAK;AAEL,MAAM,CAAC,MAAM,aAAa,GAAG,CAAC,IAA6B,EAAE,EAAE;IAC7D,OAAO,GAAG,CAAC,IAAI,CACb,EAAE,OAAO,EAAE,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,EAAE,EAChC,UAAU,EACV,EAAE,SAAS,EAAE,cAAc,EAAiB,CAAC,iBAAiB;KAC/D,CAAC;AACJ,CAAC,CAAC;AAEF,yBAAyB;AACzB,MAAM,CAAC,MAAM,WAAW,GAAG,CAAC,KAAa,EAAc,EAAE;IACvD,OAAO,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,UAAU,CAAe,CAAC;AACrD,CAAC,CAAC;AAEF,kCAAkC;AAClC,MAAM,CAAC,MAAM,kBAAkB,GAAG,CAAC,MAAc,EAAE,EAAE;IACnD,OAAO,GAAG,CAAC,IAAI,CAAC,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,gBAAgB,EAAE;QAChD,SAAS,EAAE,IAAI;KACD,CAAC,CAAC;AACpB,CAAC,CAAC;AAEF,wBAAwB;AACxB,MAAM,CAAC,MAAM,gBAAgB,GAAG,CAAC,KAAa,EAAkB,EAAE;IAChE,OAAO,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,gBAAgB,CAAmB,CAAC;AAC/D,CAAC,CAAC;AAEF,mCAAmC;AACnC,MAAM,CAAC,MAAM,iBAAiB,GAAG,CAAC,KAAa,EAAc,EAAE;IAC7D,OAAO,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,UAAU,CAAe,CAAC;AACrD,CAAC,CAAC","sourcesContent":["import crypto from 'crypto';\r\n// import jwt from 'jsonwebtoken'; Secret, SignOptions, чтобы исправить sign\r\nimport jwt, { Secret, SignOptions } from 'jsonwebtoken';\r\nimport dotenv from 'dotenv';\r\nimport { Types } from 'mongoose';\r\n\r\ndotenv.config();\r\n\r\n// console.log(crypto.randomBytes(64).toString('base64'));\r\n\r\n// 🔹 Секреты\r\n// закомитили чтобы исправить sign\r\n// const JWT_SECRET = process.env.JWT_SECRET || \"dev_secret\";\r\n// const JWT_RESET_SECRET = process.env.JWT_RESET_SECRET || \"dev_reset_secret\";\r\n// const ACCESS_EXPIRES = process.env.JWT_ACCESS_EXPIRES_IN || \"1d\"; // срок жизни access токена\r\n\r\nconst JWT_SECRET: Secret = process.env.JWT_SECRET || 'dev_secret';\r\nconst JWT_RESET_SECRET: Secret =\r\n  process.env.JWT_RESET_SECRET || 'dev_reset_secret';\r\nconst ACCESS_EXPIRES: string = process.env.JWT_ACCESS_EXPIRES_IN || '1d';\r\n\r\n// 🔹 Типы - содержать строковое поле user_id\r\nexport interface JwtPayload {\r\n  user_id: string;\r\n}\r\n\r\n// 🔹 Генерация токенов\r\n\r\n// Access токен (для авторизации)\r\n// export const generateToken = (user: { _id: Types.ObjectId }) => {\r\n//   return jwt.sign({ user_id: user._id.toString() }, JWT_SECRET as jwt.Secret, {\r\n//     expiresIn: ACCESS_EXPIRES},\r\n//   );\r\n// };\r\n\r\nexport const generateToken = (user: { _id: Types.ObjectId }) => {\r\n  return jwt.sign(\r\n    { user_id: user._id.toString() },\r\n    JWT_SECRET,\r\n    { expiresIn: ACCESS_EXPIRES } as SignOptions // подсказали тип\r\n  );\r\n};\r\n\r\n// Проверка Access токена\r\nexport const verifyToken = (token: string): JwtPayload => {\r\n  return jwt.verify(token, JWT_SECRET) as JwtPayload;\r\n};\r\n\r\n// Reset-токен (для сброса пароля)\r\nexport const generateResetToken = (userId: string) => {\r\n  return jwt.sign({ id: userId }, JWT_RESET_SECRET, {\r\n    expiresIn: '1h',\r\n  } as SignOptions);\r\n};\r\n\r\n// Проверка Reset-токена\r\nexport const verifyResetToken = (token: string): { id: string } => {\r\n  return jwt.verify(token, JWT_RESET_SECRET) as { id: string };\r\n};\r\n\r\n// 🔹 Проверка токена для Socket.io\r\nexport const verifySocketToken = (token: string): JwtPayload => {\r\n  return jwt.verify(token, JWT_SECRET) as JwtPayload;\r\n};\r\n"]}